
\documentclass[11pt,a4paper,oneside]{report}
\usepackage{mathpazo} 
\linespread{1.05}        
\usepackage[scaled]{helvet} 
\usepackage{courier} 

\normalfont
\usepackage[T1]{fontenc}
\usepackage[footnotesize]{caption}


\linespread{1.05}         

\parskip 7.2pt

\usepackage{setspace}
\onehalfspacing

\usepackage{framed}

\usepackage{pdfsync}

\setlength{\parindent}{0in} 


\usepackage[pdftex]{graphicx}

\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}


\usepackage{color}
\definecolor{gray09}{rgb}{0.9,0.9,0.9}  
\definecolor{red}{rgb}{1,0,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{lightblue}{rgb}{0,0.8,1}
\definecolor{Dark}{gray}{.2}
\definecolor{Medium}{gray}{.6}
\definecolor{Light}{gray}{.8}
\definecolor{shadecolor}{rgb}{0.9, 0.9, 1}


\usepackage{epstopdf}

\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{,}{,}

\usepackage{hyperref}
\hypersetup{colorlinks=true, 
	citecolor=blue, 
	linkcolor=black, 
	urlcolor=black}

\usepackage{pdfpages}


\usepackage{supertabular}
\usepackage{array}
\usepackage{supertabular}
\usepackage{hhline}


\usepackage{float}
\usepackage{subfig}

\usepackage{fancyhdr}
\setlength{\headheight}{15.2pt}
\pagestyle{fancyplain}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}{}}
 
\lhead{\fancyplain{}{\textit{BIAS2015}}}
\chead{}
\rhead{\fancyplain{}{\textit{\rightmark}}}
\lfoot{}
\cfoot{\fancyplain{}{\thepage}}
\rfoot{}



\newenvironment{indentexercise}[1]
{{\setlength{\leftmargin}{2em}}
\textbf{Exercise \thesubsection-#1}
\begin{list}{}
	\item
}
{\end{list}}

\newenvironment{indentFiji}
{\begin{list}{}
         {\setlength{\leftmargin}{1em}}
         \item[]
}
{\end{list}}

\newenvironment{indentCom}
{\begin{list}{}
         {\setlength{\leftmargin}{1em}}
         \item[]
}
{\end{list}}

\newcommand{\ijmenu}[1]{\texttt{\small#1}}

\newcommand{\ilcom}[1]{\texttt{\small#1}}

 \newcommand{\tab}{\hspace*{3em}}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage{textcomp}
\newcommand*{\micro}{\textmu}



\usepackage{listings}
\lstset{ 
basicstyle=\small\ttfamily, 
numbers=left,                   
numberstyle=\footnotesize,      
stepnumber=1,                   
numbersep=5pt,                  
backgroundcolor=\color{gray09},  
keywordstyle=\color{red}, 	
showspaces=false,               
showstringspaces=false,         
showtabs=false,                 
tabsize=2,                      
captionpos=b,                   
breaklines=true,                
title=\lstname,                 
escapeinside={\%*}{*)},         
morekeywords={*,...},            
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
}



\newcommand*{\titleTH}{\begingroup
\raggedleft
\textsc{\textbf{\Large{Bias2015 \hfill Module 2}}}
\HRule\\
\vspace*{\baselineskip}

\hfill \textsc{\large Authors:}\\
[0.3\baselineskip]
\hfill {\Large Kota Miura}\\
{\small EMBL Heidelberg, NIBB Okazaki}\\
\vfill

{\textcolor{Medium}{\Huge ImageJ Macro Language}}\\
[\baselineskip]
{\Large - Express Edition -}\\
[2\baselineskip]

{\bfseries BIAS2015 BioImage Data Analysis Course}\\
\textbf{EMBL Heidelberg}\\
\textbf{7-13 June 2015}

\vfill

\hfill \textsc{Reviewers / Teachers:}\\
[0.3\baselineskip]
\hfill {\large Kristine Schauer}\\
\hfill {\small Institut Curie Paris}\\
[0.3\baselineskip]
\hfill {\large Christian Tischer}\\
\hfill {\small EMBL Heidelberg}\\
[0.3\baselineskip]
\hfill {\large Chong Zhang}\\
\hfill {\small SIMBioSys, Universitat Pompeu Fabra}\\
\HRule\\

{\small \hfill\textcolor{Medium}{ Compiled on: \today }}
\endgroup}



\begin{document}

\date{\today}

\pagestyle{empty}
\titleTH
\clearpage
\pagestyle{fancyplain}

\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup

\clearpage

\setcounter{chapter}{2}


\section{Aim: Why do we write ImageJ macro?}
  
The aim of this small chapter is to teach the basics of how to automate image processing and analysis using ImageJ macro language. Why do we write ImageJ macro? We write macros to decrease our workloads in image processing: less clicking and less repetitive procedures. 
   
\section{Introduction}
  

\subsection{ImageJ macro makes your life easier}

To customize functions in ImageJ, a typical way is to write a Java plugin that directly accesses the application interface of ImageJ. 
This is a powerful method for customizing your own tool but in many cases is a bit too much for small tasks we often encounter in biological research projects. Compared to the Java programming, ImageJ macro is much easier to access and to quickly solve problems.

A typical usage is to automate repetitive tasks with hundreds of times of mouse clicking. Clicking could range from menu selections to inspection of single pixel value. By writing a macro, we could save such exhausting job to a single execution of a macro file, which is a text file with a sequence of image processing commands. As ImageJ macro functions are directly mirroring the GUI menu items, one could intuitively learn how to write one's own macro even without much experiences in programming.

Another important aspect of writing a macro is its role as a documentation: as the processing becomes complex, we easily forget the steps and details of the procedures and the values of parameters that were used for that task. Even if your job is not a repetitive one, a macro written for a task becomes a valuable record of what was done to the image, and ensures the \textbf{reproducibility} of your image analysis.  

\subsection{Other ways to Customize ImageJ}

This and the next section explain the general capability of extending ImageJ by programming. If you are not interested in general aspects, you could skip these sections.  

ImageJ could be extended by writing a Java plugin. Though you need to know or learn the Java programming,  this capability affords almost infinite possibilities;  you could write any kind of processing / analysis functions you could imagine. Compared to the plugin development by Java, ImageJ Macro language is much easier and lighter but has some limitations. It might be worth mentioning here what would be the limitations. 

\begin{enumerate}
\item If you need to process large images or stacks with many steps, 
you might recognize that it is slow. Some benchmarks indicate that a plugin would be about 40 times faster than a macro. 

\item Macro cannot be used as a library
  \footnote{It is possible to write a macro in a library fashion using the function \ilcom{eval} and use it from another macro, 
but this is not as robust and as clear as it is in Java, which is a language designed to be so.}. 
In Java, once a class is written, this could be used later again for another class. 

\item Macro is not efficient in implementing real-time interactive input 
during when the macro function is executed; 
\textit{e.g.} If you want to design a program that requires real-time user input 
to select a ROI interactively.  
Macro could only do such interactive tasks by closely related macro set with each macro doing each step of interaction. 

\item Macro is tightly coupled to GUI (Image Window), so that when you want to process images without showing them on desktop, macros are not really an optimal solution.
\end{enumerate}

If you become unsatisfied with these limitations, 
learning more complicated but more flexible Java plugin development is recommended. 


\subsection{Comparison with Other scripting languages}

Besides ImageJ macro, there are several scripting languages that
could be used for programming with ImageJ. The bare ImageJ supports Javascript (Rhino). Recent versions of ImageJ (> 1.47m,  since 6 March 2013), Jython became included in the menu as well. 
In the Fiji distribution, you could use the following languages off the shelf
\footnote{As of June, 2015}
:

\begin{itemize}
 \item Javascript
 \item BeanShell
 \item Jython (Java implemented Python)
 \item JRuby (Java implemented Ruby)
 \item Clojure
 \item Groovy
 \end{itemize}

If you set up an environment by yourself, other languages such as Scala can be used. 
Compared to the ImageJ macro language, all these languages are more general scripting languages. 

There are pros and cons. Pros of using the ImageJ Macro compared to these scripting languages are: 
\begin{itemize}
\item Easy to learn. 
ImageJ macro build-in functions are mirrors of ImageJ menu, so scripting is intuitive if you know ImageJ already. 
Macro recorder is a handy tool for finding out the macro function you need. 

\item A significant hurdle for coding with general scripting languages is that one must know the 
\textbf{ImageJ Java API} well, meaning that you basically have to know 
fundamentals of Java programming language for using these scripting languages. 

\item You could have multiple macros in one file (called 'Macro-set"). 
This is useful for packaging complex processing tasks.

\end{itemize}

Thus, ImageJ macro language is the easiest way to access the scripting
capability of ImageJ.

There are several disadvantages of ImageJ macro compared to other
scripting languages. First is its generality. Since others are based on major scripting languages, you do not need to learn a lot if you know one of them already. For example, if you know Python already, 
it should be easy for you to start writing codes in Jython (note: but you also need to know about Java). 

The second disadvantage of ImageJ macro is its extendability.
Codes you wrote could only be recycled by copying and pasting
\footnote{One could also use getArgument() and File related functions to pass
arguments from a macro file to the other, but ImageJ macro is not designed to
construct a library of functions.}.
With other scripting languages, once you write a code, it could be used from other programs
\footnote{ Calling other Javascript file from another Javascript file had been difficult but became easily possible in the Fiji distribution from March 2012.}.

Lastly, although ImageJ Macro processes with a speed comparable to
Javascript and Jython, it is slow compared to Clojure and Scala. 

\subsection{How to learn Macro programming}

In this course, you will encounter many example codes. 
You will write example codes using your own computer and run those macros. 
Modifying these examples by yourself is an important learning process as in most
cases, that is the way to acquire programming literacy. There are many excellent macro codes you could find in Internet, which could be used as starting points for writing your code\footnote{200+ macros are available in ImageJ web site. 
\href{http://rsb.info.nih.gov/ij/macros/}{http://rsb.info.nih.gov/ij/macros/}}.

\subsection{Summary}
ImageJ Macro radically decreases your work load and is a practical way to keep your image analysis workflow in text file. Less workload provides more time for us to analyze details of image data. 
The potential of macro is similar to other scripting languages and Java Plugins, all adding capability to customize your image analysis. For coding interactive procedures PlugIn works better than macro. Macro cannot be used as a library.  
Image processing by macro is slower than that by Java written plugins. 
 
\newpage

\section{Tools}
\label{sec:tools}
 
\begin{itemize}
  \item ImageJ (Fiji distribution).
  \begin{itemize}
    \item \url{http://fiji.sc}
    \item We use the Fiji distribution since it has ScriptEditor, a handy editor for writing macro. 
  \end{itemize}
  \item ImageJ Plugin: EMBL\_sampleimages-1.0.0.jar
  \begin{itemize}
     \item This plugin allows you to download sample image stacks. All the image files mentioned in this ``ImageJ Macro Language'' module could be opened by selecting the file name in \ijmenu{[EMBL > Sample Images >]}. Specified image file in the EMBL web server is then downlaoded and appears on your desktop.
    \item This plugin could be installed in one of the two following ways:
    \item First, using the ``Update Sites'' function in Fiji. Add ``CMCI-EMBL'' to your update sites by the updater interface that could be acceded via \ijmenu{[Help > Update Fiji]}. This ``update site'' function is pretty new in Fiji and usable with the latest Fiji version (2014\~)        
    \item Second, download the plugin from \url{http://cmci.embl.de/downloads/coursemodules}. 
  \end{itemize}
\end{itemize}
 
\newpage

\section{Basics}
\label{sec:ImageJMacroBasics}

  \subsection{``Hello World!''}
We first try writing a simple macro that prints ''Hello World!'' in the log window of ImageJ. For this, we use a text editor that comes with Fiji, called ``script editor''. 
It has some convenient features such as automatic coloring of macro functions {In programming world, we call this feature ``syntax highlighter''}. 

If you are not using Fiji and using native ImageJ, it's no problem as there is a simpler but perfectly working text editor. Macros we write in this textbook works exactly same in both editors. If you want to use the simple text editor for the following tutorial, its usage is explained after the explanation about Fiji edior (page \pageref{part:nativeeditor}).   

Let's open the ``script editor'' 
by \ijmenu{[File -> New -> Script]}. It should look like figure \ref{fig_ScriptEditor}.
There should be a blank text field where you write your macro. Since the editor allows you to write different scripting languages as well, you should first select the language you are going to use.  
From script editor's own menu, select \ijmenu{[Language -> IJ1 Macro]}. 

Then, write your first macro as shown below (see also figure \ref{fig_ScriptEditor}). \\
\begin{lstlisting}[numbers=none]
print("Hello World!");
\end{lstlisting}

Don't ignore quotation marks, parenthesis and the semi-colon! 
Syntax highlighter offers automatic coloring of ImageJ functions, because you selected the language "IJ macro" in above. It increases the readability of codes. 

\begin{figure}[hbtp]
\begin{center}
\includegraphics[scale=1.0]{fig/editor_helloworld_singleline.png}
\caption{Script Editor of the Fiji distribution} \label{fig_ScriptEditor}
\end{center}
\end{figure}

Then in the bottom-left corner of the script editor, there is a button labeled "Run". Clicking this, you will see that a log window is created (if it is already there, then it will have a new line) printing "Hello World!" (Figure \ref{fig_HelloWorldLog}). Another way to run the macro is via Script Editor menu,  \ijmenu{[Run -> Run]} . You could use Ctrl-R (Windows) or Command-R (OSX) as well.  

\begin{figure}[hbtp]
\begin{center}
\includegraphics[scale=1.0]{fig/helloworld_logwindow.png}
\caption{Hello World Output} \label{fig_HelloWorldLog}
\end{center}
\end{figure}

Later when you want to start writing another macro, you could just create a new tab by \ijmenu{[File > New]} and then select \ijmenu{[Language -> ImageJ Macro]} again.

\subsubsection{Simple Text Editor in native ImageJ}
\label{part:nativeeditor}

If you are using native imageJ, the the macro editor launches by selecting \ijmenu{[PlugIns -> New -> Macro]} from the menu (\ref{fig_MacroEditor}). 
Please write the following line in the editor. 
\begin{lstlisting}[numbers=none]
print("Hello World!");
\end{lstlisting}
From the menu of the macro editor (in OSX, the menu switches to the editors own menu when the editor window is active), select [Macros > Run Macro]. You should then see "Hello World!" printed in the log window. 

The macro editor has simple debugger function, which is not present in Fiji script editor. Debugger assists you to correct mistakes in the code. ImageJ Macro can be written in any text editor such as "Notepad" in Windows but of course there is no debugger function available in this case.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/editor_helloworld_IJ_simple.png}
\caption{Macro Editor of ImageJ} \label{fig_MacroEditor}
\end{center}
\end{figure}


\subsubsection{Anatomy of ``Hello World!''}

Let's see more details of what the single line code we wrote is doing.

\ilcom{print()} is a build-in macro function that requests ImageJ to take the content within the parenthesis and print that out in the "Log" window. This content, which we genearlly call the \textit{argument} of the function, is an input value given to the function. The output of this function is the printed text in the Log window. Note that when a text is given as an argument, it must be surrounded by double quotes ("").
 
Where do we get information as such for other macro functions? The best reference for ImageJ macro functions is in the ImageJ web site
\footnote{\url{http://rsbweb.nih.gov/ij/developer/macro/functions.html}}. 
For example, you could find definition of \ilcom{print("")} function on the web site as quoted below:\\
\begin{indentCom}
\fbox{
\parbox[b][20em][c]{0.80\textwidth}{
\textbf{print(string)}\\
Outputs a string to the "Log" window. Numeric arguments are automatically converted to strings. 
The print() function accepts multiple arguments. For example, you can use print(x,y,width, height) 
instead of print(x+" "+y+" "+width+" "+height). 
If the first argument is a file handle returned by File.open(path), 
then the second is saved in the referred file (see SaveTextFileDemo).

Numeric expressions are automatically converted to strings using four decimal places, 
or use the \ilcom{d2s} function to specify the decimal places. 
For example, print(2/3) outputs "0.6667" but print(d2s(2/3,1)) outputs "0.7".

\dots
}
}
\end{indentCom}

As \ilcom{print} can do many things, its explanation is extraordinary long, but by carefully reading it, you will save time afterwards by the knowledge of wide spectrum of things that the \ilcom{print} function can do e.g. directly save text as a file. 


Macro can be saved as a file.
In the editor, do \ijmenu{[File -> Save]}. Just save the file wherever you want in your file system. When you want to use the macro again, load the macro by \ijmenu{[File > Open]}.

\begin{indentexercise}{1}
\item Add another line \texttt{"print("\textbackslash{}\textbackslash{}Clear");"} 
before the first line (below, code 1.51. don't forget the semi-colon at the end!). 
\item \lstinputlisting{code/code01_51.ijm}
Then test also another macro when you put the same line after "Hello World!". 
What happened? Any difference in the behavior? 
\item \lstinputlisting{code/code01_76.ijm}
\item \textbf{Answer}: The first code prints "Hello World!", while the second code prints nothing. This is becaise \ilcom{print("\textbackslash{}\textbackslash{}Clear")} is a command that clears the Log window. In the first code, ``Hello World'' is printed after the window clearing, and in the second case the Log window is wiped out right after the printing of ``Hello World''. Effectively it looks like nothing has happened.  
\end{indentexercise}

\begin{indentexercise}{2}
\item Try modifying the third line in code 1.51
and check that the modified text will be printed in the "Log" window. \\
\end{indentexercise}

\begin{indentexercise}{3}
\item Multiple macros can exist in a single file. We call this \textbf{"macro sets"}. To distinguish each macro, each they each should have a specific name. For this, each macro should start with a special word ``macro'' followed by the name of the macro, and then a pair of curly braces to encapsulate its macro functions. See the code below.  

\lstinputlisting{code/code01_8.ijm}

Modify the code you already wrote in the script editor to wrap it inside a pair of macro bounds, the curly braces (\ilcom{\{\}}).  Then copy and paste the same under the first macro. 
The second macro should be modified to have a different name. In the example shown in fig.
\ref{fig_MacroSetInMenu}, the second macro is named "print\_out2".
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/editor_MacroSet.png}
\caption{Macro Set} \label{fig_MacroSetInMenu}
\end{center}
\end{figure}
When macro is properly declared in this way, you could install the macro to have it as a menu item. To do so, in the editor menu select: 
\begin{indentFiji}
[Run -> Install Macro]).
\end{indentFiji}
In the main menu you should no be able to see the macro names under \ijmenu{[Plugins > Macros > ]}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/firstMacroSetInMenu.png}
\caption{Macro Now in ImageJ menu} \label{fig_MacroInMenu}
\end{center}
\end{figure}
\end{indentexercise}
   \subsection{Variables and Strings}
Texts such as "Hello World!" can be represented by a variable 
\footnote{there is no declaration of types, such as number or string, in ImageJ macro.}.
Let's understand this by examining a short macro below.
\lstinputlisting{code/code02.ijm}

\ilcom{text} is a "String Variable" or simply a "String". 
ImageJ prepares a memory space for this variable, and you can change the content by re-defining the content. Two (or maybe more) variables could be used to construct another variable. 

\lstinputlisting{code/code03.ijm}

The above operation concatenates content of \ilcom{text2} to the content of \ilcom{text1} and produces a third variable \ilcom{text3} that holds the result of concatenation. It should be noted here, that macro has two ways of usage for \ilcom{+}. What we tested in above is ``concatenation''. Another usage is ``addition'' in the next section. 

\begin{indentexercise}{1}
\item Add more string variables and make a longer sentence.\\

\item **Answer**: One example could be as shown in the figure \ref{var_stringconcat}. 
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/var_stringContcat.png}
\caption{Concatenating many strings} \label{var_stringconcat}
\end{center}
\end{figure}

\end{indentexercise}


It is also possible to store a number in a variable. For example, \\
\begin{lstlisting}[numbers=none]
text = 256;
\end{lstlisting}
With this assignment, the variable is now a "numerical variable" or simply "variable". 
In other programming languages such as C or Java, difference between numbers and characters matters a lot. 
In ImageJ macro you do not have to care whether the variable is number or string (we call them ``types'') ad they are defined automatically by the type of value provided for a variable, and this makes the macro coding to be light and easy. However, since types are implicitly defined without declaration it could cause simple mistakes such as type mismatching. 
So be sure keep the difference in types DOES matter but they are not shown in the code. We will see an example of such confusion, 
and also a way to avoid the confusion. 

Test the following macro to see how the numerical variable works. 
\lstinputlisting{code/code04.ijm}
Did you get some results printed out? It should, but you should read the code carefully as there is a small trick in this code.  This trick is something special in IJ macro language compared to other general scripting languages. 

You might have noticed a strange expression at line 8, in the way it assigns the variable \ilcom{txt}. 
It starts with double quotation marks. \\
\begin{lstlisting}[numbers=none]
txt= "" + a + "+" + b + "=" + c;
\end{lstlisting}
Seemingly this looks like meaningless. 
If you define ilcom{txt} without the first "useless" quotation marks, then it will be like\\
\begin{lstlisting}[numbers=none]
txt= a + "+"+ b + "=" + c;
\end{lstlisting}
Theoretically this should work, 
since the double quote does not have any content so its presence should be meaningless. But if you try to run this what it seems to be straight-forward assignment, 
ImageJ returns an error message. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/ErrorStringNumericFunction.png}
\caption{Error with Variable Assignment} \label{fig_ErrorVariable}
\end{center}
\end{figure}

This is because when ImageJ scans through the macro from top to bottom, line by line, 
it reaches the line for the assignment of the variable \ilcom{txt} and first sees the variable \ilcom{a} and interprets that \ilcom{txt} should be a numerical variable 
(or function), since \ilcom{a} is known to be a number as it was defined so in one of the lines above. Then ImageJ goes on interpreting rightward thinking that this is math. Then finding a "+" which surprisingly is a character
ImageJ cannot interpret string variable within a numerical function, so it returns an error message. The macro aborts.  

To overcome this problem, the programmer can tell ImageJ that 
\textit{txt} is a string function at the beginning of the assignment 
by putting a set of double quote. This tells the interpreter that this assignment is a string concatenation assignment and not a numerical assignment. 
ImageJ does handle numerical values within string function, 
so the line is interpreted without problem and prints out the result successfully. Note that such confusion of string and numerical types are rarely seen in general scripting languages and specific to ImageJ macro language.

\begin{indentexercise}{2}

\item Modify the code 4, so that the calculation involves subtraction (-), multiplication (*) and division (/).

\item \textbf{Answer}: Add following lines to print results of calculations. Note that the arguments of \ilcom{print} are separated by comma, which will be space-separated text in the output.  
\begin{lstlisting}[numbers=none]
sub = a - b;
mul = a * b;
div = a / b;
print(a, "-", b, "=", sub);
print(a, "*", b, "=", mul);
print(a, "/", b, "=", div);
\end{lstlisting}

\end{indentexercise}
   \subsection{Recording ImageJ macro functions}
There are many commands in ImageJ. In the native ImageJ distribution, there are ca. 500 commands. In the Fiji distribution, there are 900+ commands. Some plugins are not macro-ready, but almost all of these commands can be accessed by build-in macro functions. That is great, but we then encounter a problem: how do we find a macro function that does what we want to do?

To show you how to find a function, we write a small macro that creates a new image, adds noise, blurs this image by Gaussian blurring, and then thresholds the image. There is a convenient tool called \textbf{Command Recorder}. 
Do \ijmenu{[PlugIns -> Macros -> Record\ldots]}. A window shown in figure
\ref{fig_macroRecorderBlank} opens.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/MacroRecorderBlank.png}
\caption{Macro Recorder} \label{fig_macroRecorderBlank}
\end{center}
\end{figure}

All the menu commands that you execute will be printed out as a history of macro functions in this window. For composing a macro using this recorder, we first do the processing manually from the menu as follows. 
\begin{itemize}
  \item Prepare a new image using \ijmenu{[File -> New]} command. The size of the image can be anything.
  \item Then do \ijmenu{[Process -> Noise -> Salt and Pepper]} (Fig.
  \ref{fig_SaltAndPepper}).
  \item \ijmenu{[Process -> Filters -> Gaussian Blur]} (use Sigma = 2.0).
  \item \ijmenu{[Image -> Adjust -> Threshold\ldots]}. Toggle the slider to make
  signals red. Check "Dark Background", then click "Apply".
\end{itemize}
 
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/SaltandPepper300.png}
\caption{A demo image for Recording Macro} 
\label{fig_SaltAndPepper}
\end{center}
\end{figure}

Now, check the Command Recorder window. 
It should look like Fig. \ref{fig_macroRecorderFilled}. 
Each line is a macro function that corresponds to a menu command you selected.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/MacroRecorderFilled.png}
\caption{Macro Recorder after some lines Recorded} 
\label{fig_macroRecorderFilled}
\end{center}
\end{figure}

These texts generated in the recorder can be used as it is in your macro.  You could copy and paste them\footnote{In case of OSX, you might probably need to click ``Create'' button to generate a duplicate of macro functions in a new script window. Then you could copy the macro functions from there.}. Compose a macro like below by copying and pasting the macro functions in the recorder.  Delete the lines that are commented out (lines that begin with "//" are lines that are skipped by the macro interpreter).
\lstinputlisting{code/code06_9.ijm}

Run the macro! \ldots I hope that you are amazed by now with the power of Macro
Recorder! Next, you could simply add a line with curly braces at the top and bottom, to package macro commands in a named macro. This is optional in the current case, but it's always a good practice to keep your macro packaged since the boundary of the macro becomes clear. 
 
\lstinputlisting{code/code07.ijm}

The third line in the above macro has a function \ilcom{newImage()}. This
function creates a new image. It has five arguments (in coding jargon, we say
there are "five arguments"). To know what these arguments are, 
the quickest way is to read the Build-In Macro Function page in ImageJ web site\footnote{\url{http://rsbweb.nih.gov/ij/developer/macro/functions.html}}.  
The description of the function \ilcom{newImage} looks like this. 

\begin{indentCom}

\fbox{
\parbox[b][16em][c]{0.80\textwidth}{
\textbf{newImage}(title, type, width, height, depth)\\
Opens a new image or stack using the name title. 
The string type should contain "8-bit", "16-bit", "32-bit" or "RGB". 
In addition, it can contain "white", "black" or "ramp" (the default is "white"). 
As an example, use "16-bit ramp" to create a 16-bit image containing a grayscale ramp.  Width and height specify the width and height of the image in pixels.  Depth specifies the number of stack slices.
}}
\end{indentCom}
Using this information, you can modify the macro to change the size of the image.

\begin{indentexercise}{1}
Modify the code 7 and try changing the size of window to be created.

\item \textbf{Answer}: Change the 3rd line as shown below. It will create a image with 500 pixels width and 200 pixels height image.  
	\begin{lstlisting}[numbers=none]
		newImage("test", "8-bit Black", 500, 200, 1);
	\end{lstlisting}
\end{indentexercise}

Other optional lines you could add to the macro are ``comments''. This does not affect the macro but adding some comment about what the macro does helps you to understand what the macro is doing when you open the file some time later. There are two ways to add comment. One is the \textbf{block comment}. Texts bounded by \ilcom{ /*} and \ilcom{*/} will be ignored by interpreter. Another is the line comment. Texts in a line starting with double slash \ilcom{//} will be ignored by the interpreter. Below is an example of commenting code 07. 

\lstinputlisting{code/code07_1.ijm}
 
\newpage

\section{Conditions and Loops}
	In many cases, we want to iterate certain processing steps many times (see "Loops" in the figure \ref{fig_scriptscheme}), or we want to limit some of the process in the program only for certain situations (see "Conditions": in the figure \ref{fig_scriptscheme}). In this section we learn how to include these loops and conditional behaviors into macro. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{fig/fig23_1_ScriptSchemes.png}
\caption{Schematic view of conditions and loops. Straightly top to bottom, line by line processing (left) and macro with loops (middle) and with a condition (right).} \label{fig_scriptscheme}
\end{center}
\end{figure}

\subsection{Loop: for-looping}
Here is a simple example macro using for-loop. Write the macro in your editor and run it. 
\lstinputlisting[morekeywords={*, for}]{code/code08_9.ijm}
The result should look like figure \ref{fig_whateverOut}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[scale=0.6]{fig/fig2311_whatever5.png}
\caption{Code 9 output in Log Window}
\label{fig_whateverOut}
\end{center}
\end{figure}

\begin{itemize}

\item Line 3 \ilcom{for( i = 0 ; i < 5 ; i += 1)} sets the number of loops. 
Three parameters are required for "for" loop. The first parameter defines the variable used for the counting loop and its initial value (\ilcom{i = 0}). The second parameter sets the condition for exiting from the loop (\ilcom{i < 5}). Third parameter sets the step size of i, meaning that how much value is added per loop (\ilcom{i += 1}, could also be subtraction, multiplication, division e.g. \ilcom{i -= 1}).
Spaces between variables, numbers, operators and separators (e.g. semicolon, parenthesis) can be ignored and they could be written continuously. Macro runs without those spaces. However, this is not recommended for keeping a better readability of the code. Don't try to rush, make spaces!
\item After this \ilcom{for(\ldots;\ldots;\ldots)} statement, there is a brace (\{) at the end of line 3 and the second one (\}) in the line 5. These curly braces tell ImageJ to loop macro functions in between so the function in line 4 will be iterated according to the parameters defined in the parenthesis of \ilcom{for}. 
Between braces, you could add as many more lines of macro functions as you want, including inner \ilcom{for}-loops and \ilcom{if-else} conditions.
\end{itemize}
So when the macro interpreter reaches line 3 and sees \ilcom{for(}, it starts looking inside the parenthesis and defines that the counting starts with 0 using a variable \ilcom{i}, and then line 4 is executed. The macro prints out "0 \ensuremath\colon whatever" using the content of \ilcom{i}, string \ilcom{\ensuremath\colon} and the string variable \ilcom{txt}. 
Then in line 5, interpreter sees the boundary \ilcom{\}} and goes back to line 3 and adds 1 to i (because of \ilcom{i+=1}). i = 1 then, so \ilcom{i<5} is true. The interpreter proceeds to line 4 and executes the macro function and prints out "1\ensuremath\colon whatever".  Such looping will continue until i = 5, since only by then \ilcom{i<5} is no longer true so interpreter exits from the for-loop. \\

\begin{indentexercise}{1}
(1) Change the first parameter in \ilcom{for(i=0;i<5;i+=1)} so that the macro prints out only 1 line. 

(2) Change the second parameter in \ilcom{for(i=0;i<5;i+=1)} so that the macro prints out 10 lines. 

(3) Change the third parameter in \ilcom{for(i=0;i<5;i+=1)} so that the macro prints out 10 lines. 

\item \textbf{Answer}: 
	\item (1) \ilcom{for(i=4;i<5;i+=1)}
	\item (2) \ilcom{for(i=0;i<10;i+=1)}
	\item (3) \ilcom{for(i=0;i<5;i+=0.5)}
\end{indentexercise}


\subsubsection{Stack Analysis by for-looping}
\label{sec:forloopStack}
One of frequently encountered tasks is image stack management, 
such as measuring dynamics or multi-frame processing. 
Many ImageJ functions work with only single frame within a stack. 
Without macro programming, you need to execute the command while you flip the frame manually. 
Macro programming enables you to automate this process. 
Here is an example of measuring intensity change over time\footnote{What we write as macro here could be done with a single command \ilcom{[Image > Stacks > Plot Z-Profile]} but this only measures intensity. If you want to measure other values such as the minimum intensity, a macro should be written. }. 

\label{code:10}
\lstinputlisting[morekeywords={*, run, setSlice, nSlices}]{code/code10.ijm}

\begin{itemize}
\item Line 3: \ilcom{nSlices} is a macro function that returns the number of slices in the active stack. 

\item Line 4: Sets measurement parameters, from the menu would be \ilcom{[Analyze > Set measurements\ldots]}. In this case "mean min integrated" is added as part of the second argument. ``mean'' is the mean intensity, ``min'' is the minimum intensity and ``integrated'' is integrated density (total intensity). These keys for measured parameters could be known by using the command recorder. 
You do not have to care for now about the "redirect" argument. ``decimal'' is the number of digits to 
the right of the decimal point in real numbers displayed in the results table. 

\item Line 5: clears the results table. 

\item Line 6 to 9 is the loop. Loop starts from count i=0, and ends at i=frame-1. \ilcom{i++} is another way of writing \ilcom{i = i + 1}, so the increment is 1.  

\item Line 7: calculates the current frame number. 

\item Line 8: \ilcom{setSlice} function sets the frame according to the frame number calculated in line 6. 

\item Line 9:  actual measurement is done. 
Result will be recorded in the memory and will be displayed in the Results table window. 
\end{itemize}

Open an example stack \textbf{1703-2(3s-20s).stk}
\footnote{Some of you may realize that you used this sequence 
in the Image Processing / Analysis Course for learning 
stack measurements using Z-profiler \ilcom{[Image > Stacks > Plot Z-Profile]}. Now, you can program similar 
device in macro. 
Good thing about the custom program
is that you will be able to modify the program further to add more functions.
For example, You could measure the time course of standard deviation of
intensity within the selected ROI.}. This is a short sequence of FRAP analysis,
so the edge of the one of the cells is bleached and then fluorescence signal at that bleached position recovers by time. 
Select the frapped region by ROI tool (such as in the figure below). 
Execute the macro. Results will be printed in the Results window (see the table in the figure right: this table is showing only "Mean" column as only ``Mean Intensity'' was selected in the measurement option). 

\begin{figure}[htbp]
 \centering
 \subfloat[]{\label{fig:frapimage}\includegraphics[height = 60mm]{fig/fig2321a_frapimage.png}}
 \quad
 \subfloat[]{\label{fig:frapmeasured}\includegraphics[height = 60mm]{fig/fig2321b_frapResults.png}}
 \caption{Measuring Stack Intensity Series. (a) Setting a Segmented ROI at the FRAPped area. (b) Results of Measuring Mean Intensity Dynamics.}
 \label{fig:frapresults}
\end{figure}


Measurement parameters can be added as argument by modifying the line 4 in the code 10.

\begin{indentexercise}{1}
Modify code 10 to include more measurement parameters (whatever you like), and test the macro. Check the results. 

\item \textbf{Answer}:``Set Measurement'' could be added with more parameters to be measured, and the digits after the decimal point could be increased by increasing the number after ``decimal=''. For example, 
\begin{lstlisting}[numbers=none]
run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding integrated median stack redirect=None decimal=5");
\end{lstlisting}

\end{indentexercise}

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5]{fig/fig2322_moreResultsTable.png}
\caption{An example result after adding more measurement parameters.}
\label{fig_MoreMeasurementPara}
\end{center}
\end{figure} 


\subsection{Loop: while-looping}

Another way of letting a part of macro to loop is \textbf{while}-statement. In this case, iteration is not defined strictly. Looping continues until certain condition is met. As soon as the condition is violated, macro interpreter goes out from the loop.

\subsubsection{Basics of while statement}
Here is a simple example macro using \ilcom{while}.
\lstinputlisting[morekeywords={*, while}]{code/code11.ijm}
This macro prints out characters 0 to 90 with a 10 increment. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.4]{fig/fig2331_Code11out.png}
\caption{Output of code 11}
\label{fig:code11 output}
\end{center}
\end{figure} 

\begin{itemize}
\item line 3: The macro interpreter first assigns 0 to the counter.
\item line 4: The interpreter evaluates if the counter value is less than or equal to 90. Since counter is initially 0\ldots 
\item line 5: Printing function is executed. 
\item line 6: counter is added with 10. 
\item line 7: the interpreter realizes the end of "while" boundary and goes back to line 4. Since counter= 10 <= 90, line 5 is again executed\ldots and so on. When counter becomes 100 in line 6 after several more loops, counter is no longer <=90. So the interpreter goes out from the loop, moves to line 8. Then the macro is terminated.
\end{itemize}

Line 6 could be written in the following way as well.
\begin{lstlisting}[numbers=none]
counter += 10;
\end{lstlisting}
This means that "counter" is added with 10. Similarly, subtracting 10 from counter is 
\begin{lstlisting}[numbers=none]
counter -= 10;
\end{lstlisting}
Multiplication is 
\begin{lstlisting}[numbers=none]
counter *= 10;
\end{lstlisting}
Division is
\begin{lstlisting}[numbers=none]
counter /= 10;
\end{lstlisting}
If the increment is 1 or -1, (counter +=1 or counter-=1), then one could also write them  as 
\begin{lstlisting}[numbers=none]
counter++;
 or 
counter--;
\end{lstlisting}
These two last macro functions are said to work faster than +=1 or -=1, but I myself do not see much difference. Computers are fast enough these days. 

\begin{indentexercise}{1}
(1) Try changing code 11 so that it uses "+=" sign.\\
(2) Change code 11 so that it uses "++" sign, and prints out integers from 0 to 9.\\

\item \textbf{Answer}: (1) Change line 6 to \ilcom{counter += 1;}. (2) Change line 4 to \ilcom{while (counter<=9)} and line 6 to \ilcom{counter++}.
\end{indentexercise}

\begin{indentexercise}{2}
Change line 4 of code 11 to \ilcom{while (counter <0)} and check the effect (see below).
\end{indentexercise}

Evaluation of \ilcom{while} condition could also be at the end of loop. In this case, \ilcom{do} should be stated at the beginning of the loop. With do-while combination, the loop is always executed at least once, regardless of the condition defined by \ilcom{while} since macro interpreter reads lines from top to bottom. Write the following code.

\lstinputlisting[morekeywords={*, while}]{code/code11_5.ijm}

In this example, the exit condition for going out from looping is \ilcom{counter < 0}, and the initial value of \ilcom{counter} is 0, which does not satisfy that looping condition. Since this evaluation occurs only after the looping part is executed for the first time, the macro still prints out a line before it exits from the loop.  


Condition for the while-statement could be various. Here is a small list of comparison operators.

\begin{indentCom}
 \begin{tabular*}{0.5\textwidth}{ l r }
< & less than \\
<= & less than or equal\\ 
> & greater than\\ 
>= & greater than or equal to\\
== & equal\\
!= & not equal\\
 \end{tabular*}
\end{indentCom}

\begin{indentexercise}{3}
Modify code 11 so that the macro prints out numbers from 200 to 100, with an increment of -10. 

\item \textbf{Answer}: There could be slightly various ways to do this modification, but here is one way. 
	\begin{lstlisting}
macro "while looping1" {
	counter=200;
	while (counter>=100) {
		print(counter);
		counter -= 10;
	}
}
\end{lstlisting}

\end{indentexercise}


\subsubsection{Why is there while-loop?}

An often raised question with the while-loop is why do we have two types of loops, 
the for-loop and the while-loop. Answering to this question, they have different
flexibility. The for-loop is rather solid and the while-loop is more flexible. In the
example code below, the user is asked for a correct number and if the answer is wrong, the
question is asked 5 times repeatedly. Number of loop is not determined by the
programmer, but interactively when the code is running. We will study
the branching of the program based on if-else in the next section.  

\lstinputlisting[morekeywords={*, while}]{code/code11_6.ijm}

Writing a similar code using the for-loop is possible but the code becomes tricky.
Below is the for-loop version of the above code.  

\lstinputlisting[morekeywords={*, for}]{code/code11_7.ijm}

Note that the third argument of for-loop is missing. Since the variable
\ilcom{correct} does not change as long as the answer is wrong, we leave it not
incrementing nor decrementing. In such case we can leave the third argument
vacant. 

\subsection{Conditions: if-else statements}
\subsubsection{Introducing if-else}
A macro program could have parts which are executed depending on some
conditions.
Here is an example of macro with conditions.
\lstinputlisting[morekeywords={*, if}]{code/code12.ijm}
\begin{itemize}
\item Line 3 The macro asks user to input a number and the number is substituted to the variable input\_num.
\item Line 4 Content of input\_num is evaluated. If input\_num is equal to 5, line 5 is executed and prints out the message in the Log window. Otherwise macro interpreter jumps to line 7, and ends the operation.  By adding "else" which will be executed if input\_num is not 5, the macro prints out message in all cases (see code 12.5 for this if - else case). 
\item Line 4 We used double equal signs for evaluating the value in the right side and the left side (e.g. \ilcom{if (a==5)}). 
Note that the role of the sign \ilcom{=} is different from assignments, or substitution (e.g. \ilcom{a = b + c}).
\end{itemize}
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/fig2341_code12out.png}
\caption{Output of code 12}
\label{fig:code12 output}
\end{center}
\end{figure} 

Now, we examine the content between 
parenthesis after ``if'' in more detail. 
Write the following code in your script editor and run it.
\lstinputlisting[morekeywords={*, ==}]{code/code12_1.ijm}
The output in the log window should be \textit{1} indicating that ``\ilcom{(5 ==
5)}'' is \textit{1}. Next, modify the code like below and run it.
\lstinputlisting[morekeywords={*, ==}]{code/code12_2.ijm}
The output is now 0, indicating that ``\ilcom{(5 == 4)}'' is
0.
What double equal signs \ilcom{==} are doing in these
examples are comparison of numbers in the left and the right side, and if
the numbers are the same, it returns 1 and if they are not the same, it returns 0. 1 and
0 actually are representing \textbf{true} (= 1) or \textbf{false} (= 0), the
\textbf{boolean values}.

We could also test if they are NOT equal. For this, replace \ilcom{==} by
\ilcom{!=}.
\lstinputlisting[morekeywords={*, !=}]{code/code12_3.ijm}
Run the code above, and it returns 1, because 5 is NOT 4 and that is true. Now,
you could introduce the \textit{if} again as follows.
\lstinputlisting[morekeywords={*, if, else}]{code/code12_35.ijm}
In the parenthesis after ``if'', there is obvious TRUE statement (5 is not 4).
This is true, so the macro function bounded by curly braces is executed, which is to
print out ``true'' in the log window.

Try changing the line 2 to \ilcom{if (5 == 4)}. Running this prints nothing
in the log window, because 5 is not 4 (FALSE!) so that the macro function in
line 3 is ignored. To avoid such ignorant no-output behavior, you could add
``else'' as follows.

\lstinputlisting[morekeywords={*, if, else}]{code/code12_4.ijm}

The code works also with the direct true or false
declaration inside the if parenthesis. Try the following code.

\lstinputlisting[morekeywords={*, if, else}]{code/code12_5.ijm}

The above prints two lines of ``false!'' in the log window. You could replace
the if parenthesis values to 1 and true to check that it works as well. 

By now, it is probably pretty clear to you wi what is going on in the code below. 
\lstinputlisting[morekeywords={*, if, else}]{code/code12_6.ijm}

\subsubsection{Complex Conditions}
In many cases, you might need to evaluate the condition of multiple variables at once. 
For such demands, several different comparisons can be combined by using following Boolean operators. 

\begin{indentCom}
 \begin{tabular*}{0.5\textwidth}{ l l }
\&\& & boolean AND\\
|| & boolean OR\\
\end{tabular*}
\end{indentCom}

Let's first test what these symbols do by directly using
\ilcom{true} and \ilcom{false} in macro.
\lstinputlisting[morekeywords={*, if, else}]{code/code12_65.ijm}
When you run this code as it is, line 4 and line 8 are both executed and prints
the messages. For the first \ilcom{if} parenthesis, \ilcom{\&\&} operator tests if
both sides are true. If both are indeed true, it returns true (1), and that is
the case above. If one of them or both are false, then \ilcom{\&\&}
operator returns false(0). 

On the other hand, in the second if parenthesis,
\ilcom{||} operator tests if one of the two sides is true. Since both are
true in the above code, OR operator returns true because at least one of them is
true. Only when both sides are false, the returned value becomes false (0).

\begin{indentexercise}{1}
Adjust the values of \ilcom{a} and \ilcom{b} in code 12\_65 to \ilcom{true} or \ilcom{false} and
compose other three possible combinations (e.g. \ilcom{a = true}, \ilcom{b = false} will print
only one line). Check the output.

Next, change the values of \ilcom{a} and \ilcom{b} to 0 and/or
1 and check the results. 
\end{indentexercise}

Here is a more realistic example (though not very useful), an extended version
of code 16\_6.
\lstinputlisting[morekeywords={*, if, else}]{code/code12_75.ijm}
\begin{itemize}
\item Line 4 and 5 ask user to input two parameters.
\item Line 6 is for setting a string variable, to abbreviate a long string assignment that appears four times in the macro.
\item Line 7 evaluates these input parameters by comparing each of them separately, but the decision is made by associating two decisions with \ilcom{\&\&}. 
\item Line 10, != compares left and right sides of the operators and returns true if they are NOT equal.   
\end{itemize}
From line 10 to 17, there are several layers of conditions. Macro programmer should use tab-shifting for deeper condition layers as above for the visibility of code. Easy-to-understand code helps the programmer oneself to debug afterward, and also for other programmers who might reuse the code.
 		
\subsubsection{Application of if-statement}
\label{sec:dotmove}

As an application of looping and conditions, we write a macro that produces an animation of moving dot. User inputs the speed of the dot, and then the animation is generated. 
In the animation (which actually is a stack) the dot moves horizontally and bounces back from the edge
of the frame. 
\ilcom(if) operator is used to switch the movement direction.
\lstinputlisting[morekeywords={*, setForegroundColor, setBackgroundColor, if}]{code/code13.ijm}

\begin{itemize}
\item Lines 4 to 11: Set parameters for drawing a dot. It is also possible to directly use numerical values in the later lines, but for the sake of readability of the code, and also for possible later extension of the code, it is always better to use easy-to-understand variable names and explicitly define them before the main part starts. 
\item A short note on the x-y coordinate system in digital images: Since digital image is a matrix of numbers, each pixel position is represented as coordinates. The top left corner of image is the position (x, y) = (0, 0). X increases horizontally towards right side of the image. Y increases vertically towards the bottom of the image.  In line 11, y-position of the dot is defined to be placed in the middle of the vertical axis. 
\item Lines 14, 15: These lines set the drawing and background color. Three arguments are for intensity of each RGB component. Here the image is in grayscale so all the RGB components are set to the same value. 0 is black, and \ilcom{int} is white (255).
\item Line 18 asks the user to input the speed of the dot movement.
\item Lines 21, 22 prepares a new stack with parameters defined in lines 7, 8 and 9.
\item Lines 25 to 34 is the loop for drawing moving dot. Loop will be iterated from the starting frame until the last frame. Line 32 creates an oval Region-of-Interest (ROI), which will be filled in line 33 with the foreground color that was already set in the line 14. \ilcom{makeOval} function is explained in the Built-in function page as follows.

\begin{indentCom}
\textbf{makeOval}(x, y, width, height)\\
Creates an elliptical selection, where (x,y) defines the upper left corner of the bounding rectangle of the ellipse. 
\end{indentCom}
\item Line 27: Shifts the x position of the dot by ``speed'' distance. 
\item Line 28: if the position calculated in the line 27 exceeds the boundary, either left \ilcom{(x\_position < 0)} OR right \ilcom{(x\_position > (w-sizenum))}, then the direction of movement is switched by multiplying -1.
\end{itemize}
\begin{indentexercise}{2}
Modify code 13 that the dot moves up and down vertically. Change the stack width and height as well. 

If you are successful with this, try further on to extend the code so that the dot moves both in x and y directions. For this, you need to have two independent speed \ilcom{xspeed} and \ilcom{yspeed} since change in the direction by bouncing should be independent in x and y. 

\item \textbf{Answer}: By swapping x and y values, the movement becomes vertically oriented. We first swap the values of frame size and the initial position of the dot.  
	\begin{lstlisting}[numbers=none]
		w = 50;
		h = 200;
		x_positon =  (w/2)-(sizenum/2);
		y_position = sizenum;
	\end{lstlisting}
	Then line 27 to 31 should be changed to move the dot in y (vertical) direction, and also to change the condition for bouncing at walls.
	\begin{lstlisting}[numbers=none]
		y_position += speed;
		if ((y_position > (h-sizenum)) || (y_position < 0) ) { 
			speed*=-1;
			y_position += speed*2;
		}
	\end{lstlisting}

\end{indentexercise}

 
\newpage

\section{Advanced Topics}
\label{sec:advancedTopics}

  \subsection{User-defined Functions}

As your code becomes longer, 
you will start to realize that similar processing or 
calculation appears several times in a macro or through macro sets. 
To simplify such redundancy, one could write a 
separate \ilcom{function} that works as a module for macros. 
For example, if you have a simple code like:
\lstinputlisting[morekeywords={*,}]{code/code15.ijm}
It should be easy for you to expect that this macro will print out "3" in the Log window. 
From this macro, we could extract part of it and make a separate function. 
\lstinputlisting[morekeywords={*,}]{code/code15_1.ijm}
This is not a macro, but is a program that works as a unit. 
Functions can be embedded in macro. \ilcom{ReturnAdd }(code 15.1) is the name of the function, 
and the following \ilcom{(n, m)} are the variables that will be used in the function. Within the function, 
n and m will be added and the result of which is substituted in to a new variable p. 
\ilcom{return p} in line 4 will return a value as an output of the function. 
We call such custom-made function as ``user-defined function''. Using this function, code 15 can be rewritten as
\lstinputlisting[morekeywords={*,}]{code/code15_2.ijm}
or simpler, by nesting the custom made function inside ImageJ native function \ilcom{print()},
\lstinputlisting[morekeywords={*,}]{code/code15_3.ijm}
Macro interpreter reads the macro line by line. When the interpreter sees \ilcom{ReturnAdd(a, b)}, 
the interpreter first tries to find the function within the ImageJ Build-in function. 
If its not there, the interpreter looks for the function within the same macro file\ldots 
(user-defined function (e.g. \ilcom{ReturnAdd(a, b)} must be written in the same macro file. 
Here is how it looks like: a macro that uses a function. 
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/fig2411_usingFunction.png}
\caption{A macro file with function}
\label{fig:MacroWithFunction}
\end{center}
\end{figure} 

In this simple case, 
you might not feel the convenience of the user-defined function, 
but you will start to feel its power as you start writing longer codes. 
Advantages of using \ilcom{function} are
\begin{enumerate} 
\item Once written in a macro file, it could be used as a single line function 
as many times as you want in the macro file. This also means that if there is a bug, 
fixing the function solves the problem in all places where the function is used.
\item Long codes could be simplified to an explicit outline of events. Such as:
\begin{lstlisting}[numbers=none]
macro "whatever" {
    	function1;
		function2;
		function3;
}
\end{lstlisting}
\end{enumerate}
   \subsection{String Arrays}
Array is a powerful tool. before going into how to use it, here is an easy explanation. 
Imagine that an array is a stack of boxes. Boxes could contain either numbers or strings. 
For instance, if you have a following list of strings:

\textit{Heidelberg, Hamburg, Hixton, Grenoble, Monterotondo}

An array "EMBL" could be prepared and each array element could contain one of these five strings. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.6]{fig/fig2441_arrayScheme.jpg}
\caption{EMBL array}
\label{figEMBLarray}
\end{center}
\end{figure} 
 
Then when you want to retrieve some name from the array, you refer to the address within the array. 
So EMBL[0] will be Heidelberg, EMBL[4] will be Monterotondo, and so on. 
In such a way, files names contained in a folder could be listed and stored, 
or x-y coordinates of free-hand ROI could be stored for further use. 

Here is a macro using the EMBL array example. 

\lstinputlisting[morekeywords={*, newArray}]{code/code20.ijm}

\begin{itemize}
\item Line 3 uses a function that creates a new array (\ilcom{newArray()}),
defined by a parameter for number of array elements (in the example case its 5) and its name \ilcom{EMBL}.
\item From line 4 to 8, each array from position 0 to 4 will be filled with
names (Array starts with 0th element).
\item Line 9 asks the user to input the address (position) within the array.
Then this input address is examined if the address exists within the
\ilcom{EMBL} array in line 10. \ilcom{EMBL.length} returns the number of "boxes"
within the array. If this is satisfied, then line 10 prints out the string in that address.
\end{itemize}

Array could be created and initialized with actual values at the
same time, so line 3 to 8 could be written in a single line like this: 
\begin{lstlisting}[numbers=none]
EMBL = newArray("Heidelberg","Hamburg","Hixton","Grenoble","Monterotondo");
for (i = 0; i < EMBL.length; i++)
    print(EMBL[i]);
\end{lstlisting}   \subsection{Numerical Array}
\label{subsec:numericalarray}
Array could also contain numerical values, and this way of usage is more common when you do image analysis. Here is a simple example of numerical array that prints out intensity profile along selected line ROI. 

\lstinputlisting[morekeywords={*, newArray, selectionType, getProfile, setResult, updateResults}]{code/code20_5.ijm}

\begin{itemize}
\item Line 3: Check if the selection type is a straight line ROI. If not, macro terminates leaving a message. 

\begin{indentCom}
\textbf{selectionType}()\\ 
Returns the selection type, where 0=rectangle, 1=oval, 2=polygon, 3=freehand, 4=traced, 5=straight line, 6=segmented line, 7=freehand line, 8=angle, 9=composite and 10=point. Returns -1 if there is no selection.
\end{indentCom}

\item Line 4: Empty array \ilcom{tempProfile} is loaded with the intensity profile along the line ROI by \ilcom{getProfile}().
\item
\begin{indentCom}
\textbf{getProfile}()\\
Runs \ijmenu{[Analyze > Plot Profile]} (without displaying the plot) and returns the intensity values as an array.
\end{indentCom}

\item Line 5: Passing the array \ilcom{tempProfile} to function "output\_results", which prints the content of array in the table shown in the ``Results'' window. 

\item Line 7 to 14: A function for outputting the profile array in the table shown in the ``Results'' window. It takes an argument \ilcom{rA}, which is supposed to be an array. 
\item Line 8: Clears the results table. 
\item Line 9 to 12: for-loop to go through the array and to print out each element. 
\item Line 10: Sets the pixel position along the segment in the column labeled "n". 
\item Line 11: Sets the content of the array (pixel intensity) in the column labeled "intensity".

\begin{indentCom}
\textbf{setResult}("Column", row, value)
Adds an entry to the ImageJ results table or modifies an existing entry. The first argument specifies a column in the table. If the specified column does not exist, it is added. The second argument specifies the row, where 0<=row<=nResults. (nResults is a predefined variable.) A row is added to the table if row=nResults. The third argument is the value to be added or modified. 
\end{indentCom}
\item Line 13: Updates the table shown in the ``Results'' window. 

\begin{indentCom}
\textbf{updateResults}()
Call this function to update the "Results" window after the results table has been modified by calls to the setResult() function. 
\end{indentCom}
\end{itemize}

\begin{indentexercise}{1}
Modify code 20.5 that the macro calculates the sum of all intensities.\\

Hint:

\begin{itemize}
\item
\item You do not need the function anymore. 
\item \ilcom{for}-loop should be used.
\item Use \ilcom{tempProfile.length}
\end{itemize}

\item \textbf{Answer}: The key for getting the sum of values in an array is for-loop to go through all elements of the array. The total sum of array values is calculated by adding up values during this for-loop.   
\begin{lstlisting}[numbers=none]
macro "get profile and printout" {
	if (selectionType() !=5) exit("selection type must be a straight line ROI");
	tempProfile=getProfile();
	sum = 0;
	for (i = 0; i < tempProfile.length; i++){
		sum += tempProfile[i];
	}
	print("sum of values:", sum);
}  
\end{lstlisting}

Another way of achieving the similar task is by using Array related function. We will see this later. 
\end{indentexercise}
   \subsection{Array Functions}

Arrays could be directly treated using array functions. Since array is a very usable form of holding numbers and strings, it's good for you to know what they could do. Here is the list. 

\begin{shaded}\begin{indentCom}
\item \textbf{Array.concat(array1,array2)} Returns a new array created by
joining two or more arrays or values. 
\item \textbf{Array.copy(array)} Returns a copy of array. 
\item \textbf{Array.fill(array, value)} Assigns the specified numeric value to
each element of array.
\item \textbf{Array.findMaxima(array, tolerance)} Returns an array holding the peak positions (sorted with descending strength). Tolerance is the minimum amplitude difference to needed to separate two peaks. There is an optional 'excludeOnEdges' argument that defaults to 'true'. Examples. Requires 1.48c.
\item \textbf{Array.findMinima(array, tolerance)} Returns an array holding the minima positions. Requires 1.48c.
\item \textbf{Array.fourier(array, windowType)} Calculates and returns the Fourier amplitudes of array. WindowType can be "none", "Hamming", "Hann", or "flat-top", or may be omitted (meaning "none"). See the TestArrayFourier macro for an example and more documentation. Requires 1.49i. 
\item \textbf{Array.getStatistics(array, min, max, mean, stdDev)} Returns the
min, max, mean, and stdDev of array, which must contain all numbers.
\item \textbf{Array.print(array)} Prints the array on a single line. 
\item \textbf{Array.rankPositions(array)} Returns, as an array, the rank
positions of array, which must contain all numbers or all strings. 
\item \textbf{Array.resample(array,len)} Returns an array which is linearly resampled to a different length. Requires 1.47j. 
\item \textbf{Array.reverse(array)} Reverses (inverts) the order of the
elements in array. 
\item \textbf{Array.show(array)} Displays the contents of array in a window. Requires 1.48d.
\item \textbf{Array.show("title", array1, array2, ...)} Displays one or more arrays in a Results window (examples). If title (optional) is "Results", the window will be the active Results window, otherwise, it will be a dormant Results window (see also IJ.renameResults). If title ends with "(indexes)", a 0-based Index column is shown. If title ends with "(row numbers)", the row number column is shown. Requires 1.48d. 
\item \textbf{Array.slice(array,start,end)} Extracts a part of an array and
returns it. 
\item \textbf{Array.sort(array)} Sorts array, which must contain all numbers
or all strings. String sorts are case-insensitive in v1.44i or later.
\item \textbf{Array.trim(array, n)} Returns an array that contains the first n
elements of array.
\end{indentCom}\end{shaded}

For example, array could be sorted and reversed. Try the following codes. 

\begin{lstlisting}[numbers=none]
EMBL = newArray("Heidelberg","Hamburg","Hixton","Grenoble","Monterotondo");
Array.print(EMBL);
Array.sort(EMBL);
Array.print(EMBL);
Array.reverse(EMBL);
Array.print(EMBL);
\end{lstlisting} 
The output of this code is:
\begin{lstlisting}[numbers=left]
Heidelberg,Hamburg,Hixton,Grenoble,Monterotondo
Grenoble,Hamburg,Heidelberg,Hixton,Monterotondo
Monterotondo,Hixton,Heidelberg,Hamburg,Grenoble
\end{lstlisting} 
The first line is printed in the order when the array was initialized. After
sorting, names are in alphabetical order. Third line shows the reversed
elements. 

Some functions return an array rather than taking array/s as argument. See Appendix for a list of those functions (\ref{subsec:arrayreturn}).
   \subsection{Application of Array in Image Analysis}
\subsubsection{Intensity Profile and Array Functions}

To learn the actual use of array in image analysis, we explore several example applications. In the first application, we use \ilcom{getProfile} function. We already used \ilcom{getProfile()} in the section \ref{subsec:numericalarray} ``Numerical Array''. This time, we use it in combination with Array functions to get local minima along the intensity profile - just like finding downward peak positions. We use a sample image Tree\textunderscore Rings.jpg (\ijmenu{[File > Open Samples > Tree Rings]}). 
 
We draw a straight line ROI crossing tree rings, and then the aim of the macro we will write is to detect ring positions along that line ROI and indicate those positions by point ROIs. The macro first reads the line-profile from the straight line ROI and then we use \ilcom{Array.findMinima} function to detect local minima (dark rings). Since this function returns the position of minima only as indices of the line-profile array, we need to get \ilcom{x} and \ilcom{y} coordinates of minima from their indices in order to plot minima positions in the original image. For this purpose, we resample the straight line ROI to the same number of points as the length of line-profile array. Let's write the code and learn by doing. 

Note: Before running the macro code20\_4.ijm, be sure to have a straight line ROI placed crossing tree rings (fig. \ref{fig:treeRingsSelected}). 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{fig/Tree_Rings_Selected.png}
\caption{A strainght Line ROI crossing rings.}
\label{fig:treeRingsSelected}
\end{center}
\end{figure}


\lstinputlisting[morekeywords={*, getProfile, Array, findMinima, resample, print, getStatistics}]{code/code20_4.ijm}


\begin{itemize}
\item line 3 - 4:  Check if the selection type is a straight line ROI using function \ilcom{selectionType}. If not, macro terminates leaving a message.
\item Line 5: An intensity profile array \ilcom{pA} is sampled by \ilcom{getProfile}().
\item Line 6: Detect local minima using \ilcom{Array.findMinima}. The first argument is the line-profile array, and the second argument is ``tolerance''. A larger tolerance value is less sensitive to intensity minimum - less detection. You could try changing this value later to see the effect. An array containing indices of minima positions is returned. 
\item Line 7: \ilcom{getSelectionCoordinates} with straight-line ROI stores two arrays, each for start/end x coordinates and start/end y coordinates. Two arrays, in this case \ilcom{xpoints} and \ilcom{ypoints}, have length of two. 
\item Line 8 - 9: Resampling of straight-line ROI by number of points in the line-profile array \ilcom{pA}.
\item Line 10-11: Prepare two new arrays to store x and y coordinates of minima positions. 
\item Line 12: For-loop to go through minima indices array. 
\item Line 13-14: \ilcom{minsA[i]} is the index for a single minimum, and using that index, x and y coordinate of that minimum position is retrieved and stored into new arrays prepared in line 10-11. 
\item Line 16: After the looping, x and y coordinates of minima are used in \ilcom{makeSelection} function to create multiple point ROI. 
\end{itemize}

Run the code, then you should see multiple point ROIs indicating positions of rings (See fig. \ref{fig:treeRingsSelected}). Similar macro can be used to measure striated pattens in tissues or cell edges. In case of fluorescence images, \ilcom{Array.findMaxima} can be used to detect high-intensity maxima positions. 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=0.9\textwidth]{fig/Tree_Rings_Minima.png}
\caption{Detected ring positions.}
\label{fig:treeRingsMinima}
\end{center}
\end{figure}



\subsubsection{Extending Stack Analysis by Direct Measurements}

We studied how to use for-loops to measure each frame/slice within a stack (\ref{sec:forloopStack}). There we did measurements by firstly setting measurement parameters with \ilcom{run("Set Measurements...")} and then did measurement by \ilcom{run("Measure")}. Measured values were shown in the table in the ``Results'' window. To use those measured values to \textit{e.g.} calculate statistics or plot the results, one should access the table in the ``Results'' window and parse all the values. This is possible with the macro language, but we will not try this method as it is indirect. Instead, we try to access directly to the measured values and compute. There are two ways. 

\begin{enumerate}
\item \ilcom{getRawStatistics(nPixels, mean, min, max, std, histogram)}
\item \ilcom{List.setMeasurement}
\end{enumerate}
The function \ilcom{getRawStatistics} measures statistical parameters from the image and returns those values in the variables declared as arguments. In other words, after this function is executed, variable \ilcom{mean} will have the mean intensity of the image
\footnote{In this example we use a variable named \ilcom{mean}, but the name could be anything such as \ilcom{a} or \ilcom{b}.}. 
If a ROI is selected, mean intensity of that ROI will be the value of \ilcom{mean}. We could loop each slice/frame within a stack and for each loop we could do \ilcom{getRawStatistics} and store measured values in arrays. But there is a drawback of using this function: the available parameters to measure is limited. 

The second method \ilcom{List.setMeasurement} does not have this limitation. One could measure many more parameters because all the available parameters listed in \ilcom{[Analyze > Set Measurements...]} are accessible with this function. The basic usage is shown in the code below, which measures the currently active image, extracts specific measurement value (in this example case ``Mean'' intensity) and then prints out that value in the log window. Try writing this code and test it with any image. 

\begin{lstlisting}
List.setMeasurements;
mean = List.getValue("Mean");
print(mean)
\end{lstlisting}

We could do the measurement using \ilcom{List.setMeasurement} function for every loop for stack slices/frames and store the results in arrays. Here is the code, a modified version of code 10 (p~\pageref{code:10}). 

\lstinputlisting[morekeywords={*, List, setMeasurements, getValue, newArray}]{code/code10_1.ijm}

\begin{itemize}
  \item Line 2: Checks the ImageJ version, since \ilcom{List.setMeasurements} function is only available after version 1.42i.
  \item Line 5, 6: Create new arrays with their length equal to the number of frames of the stack. These arrays will be used to store measurement results. 
  \item Line7: for-loop going through each frames in the stack.
  \item Line 10: Measure. All the parameters will be stored in the List. 
  \item Line 11, 12: Retrieve the results, mean intensity and its standard deviation. 
  \item Line 15, 16: Print out results in the log window. 
\end{itemize}
   \subsection{Working with Strings}

With some advanced macro programming, you might need to manipulate Strings (texts) from your code. For example, let's think about a title of an image ``exp13\_C0\_Z10\_T3.tif''. Such naming occurs often to indicate that this image is from the third time point (T3), at the 11th slice (Z10, imagine that the Z slice numbering starts from 0) and its the first channel (C0). 

We might be lucky enough to read out its dimensional information from header, but quite often such information is only available in the file name (the title of the image). To extract dimensional information from file name, we need to know how to deal with strings in macro to decompose those strings and extract information that we need. Build-in macro functions which are related to such tasks with strings are the following. 

\begin{shaded}\begin{indentCom}
\item lengthOf(str)
\item substring(string, index1, index2)
\item indexOf(string, substring)
\item indexOf(string, substring, fromIndex)
\item lastIndexOf(string, substring)
\item startsWith(string, prefix)
\item endsWith(string, suffix)
\item matches(string, regex)
\item replace(string, old, new)
\end{indentCom}\end{shaded}

Let's go back to the example file name ``exp13\_C0\_Z10\_T3.tif'' again. If we need to get the file name without file extension, what should we do? Several ways are there, but lets start with the simplest way. 

We already know that all the file names are in the TIFF format, so all file names end with ``.tif''.  We could remove this suffix by replacing the ``.tif'' with a string with length 0. We could do this by using \ilcom{replace}. 

\begin{lstlisting}
name = "exp13_C0_Z10_T3.tif";
newname = replace(name, ".tif", "");
print(newname);
\end{lstlisting}

This will print out "exp13\_C0\_Z10\_T3" in the log window. In the second line, the function \ilcom{replace} is used. The old string ".tif" is replaced by a new 0 length string "". So it works! 

But what if our lucky assumption that all files end with ".tif" is not true and it could be anything? To work with this, we now need to use different strategy to know the file extension. 

By definition, file extension and the file name is separated by a dot. Length of the extension could be different, as some extension such as a python file is ".py" and a C code is ".c". Thus, we cannot assume that the length of the file extension is constant, but we know that there is a dot. 

For such cases with variable length of file extension being expected, we first need to know about the \textbf{index} of the dot within file name. Each character within file name is positioned at certain index from the beginning of the name. In the example we are now dealing with, the index 0 is ``e''. The index 1 is ``x''. Since the index starts from 0, the last index will be total length of the file name minus one. You could modify the code above like below to try getting the length of the file name. 

\begin{lstlisting}
name = "exp13_C0_Z10_T3.tif";
tlength = lengthOf(name);
print(tlength);
\end{lstlisting}

You should see ``19'' in the log window. That is the length of this file name. So in this example string, index starts from 0 and the last index is 18. 

Next, we use the function \ilcom{substring(string, index1, index2)}. With this function, you could extract part of the \ilcom{string} by giving the start index (index1) and the end index (index2) as arguments. We could just try this by again modifying the code above. 

\begin{lstlisting}
name = "exp13_C0_Z10_T3.tif";
subname = substring(name, 0, 3);
print(subname);
\end{lstlisting}

The output after running this code is ``exp'' printed in the log window. The second argument of the function \ilcom{substring} is 0, and the third is 3. This tells the function \ilcom{substring} to extract characters from the index 0 to the index 2 (so the third argument will be the index just after the last index that would be included in the substring). 

\begin{indentexercise}{1}
	\item Test changing the second and the third argument so that different part of the file name is extracted.
	\item \textbf{Answer}: For example, changing the line 2 to \ilcom{substring(name, 3, 6)} prints \ilcom{13\textunderscore}
\end{indentexercise}

How could we know the index of the dot? For this we use the \ilcom{indexOf(string, substring)}. Try the following code. 

\begin{lstlisting}
name = "exp13_C0_Z10_T3.tif";
dotindex = indexOf(name, ".");
print(dotindex);
\end{lstlisting}

Now you know that the index of dot is ``15''. We could then combine the knowledge we have now to compose a single macro that extracts the filename without file extension. 

\begin{lstlisting}
name = "exp13_C0_Z10_T3.tif";
dotindex = indexOf(name, ".");
filename = substring(name, 0, dotindex);
print(filename);
\end{lstlisting}

Let's make the problem a bit more complicated. If the file name contains multiple dots, what should we do? In the example below, I added two more dots. 

\begin{lstlisting}
name = "exp13._C0._Z10_T3.tif";
dotindex = indexOf(name, ".");
filename = substring(name, 0, dotindex);
print(filename);
\end{lstlisting}

Output is now ``exp13''. Far from what we need. To treat such case, we use \ilcom{lastIndexOf}, which returns the index of the last appearance of the given character. Let's slightly modify the code. 

\begin{lstlisting}
name = "exp13._C0._Z10_T3.tif";
dotindex = lastIndexOf(name, ".");
filename = substring(name, 0, dotindex);
print(filename);
\end{lstlisting}

It should then working again as we want. 

Let's change our task: We now want to know the time point that this image was taken. How should we do that? Examining the file name again, we realize that the time point number appears after ``T''. The number could be any length of digits, but currently is 0. Then the dot comes right after the number. We then just need to know the index of ``T'' \ldots but wait, we might have ``T'' anywhere, as this is a single character alphabet that could easily be a file name. Therefore we find the index of ``\_T'' that looks like more specific. 

\begin{lstlisting}
name = "exp13._C0._Z10_T3.tif";
timeindex = indexOf(name, "_T");
print(timeindex);
\end{lstlisting}

Now we know that ``\_T'' is at index 14, so the number should start from the index 16 (because index 15 will be ``T''). Taken this into account, we could extract the time point. 

\begin{lstlisting}
name = "exp13._C0._Z10_T3.tif";
timeindex = indexOf(name, "_T");
dotindex = lastIndexOf(name, ".");
timepoint = substring(name, timeindex + 2, dotindex);
print(timepoint);
\end{lstlisting}

The time point that you have just now captured is a string. You can not pass this to mathematical assignments. To do so, you need to convert this to a number. For doing so, you could use \ilcom{parseInt(string)}. 

\begin{lstlisting}
name = "exp13._C0._Z10_T3.tif";
timeindex = indexOf(name, "_T");
dotindex = lastIndexOf(name, ".");
timepoint = substring(name, timeindex + 2, dotindex);
timepoint = parseInt(timepoint);
print(timepoint * 2);
\end{lstlisting}

An example case where conversion of string to number (in this case an integer) required would be when you need to compare such file names and get the maximum time point from all the file names. Usage is diverse, but at some point you need to use this. If you need a Float number (numbers with decimal point), use \ilcom{parseFloat(string)}.
 
\newpage

\section{Notes}
\label{sec:notes}

\section{Note}

If you want to study more about ImageJ macro, please refere to the longer version of this textbook freely downloadable from the site below:

\url{http://cmci.embl.de/documents/ijcourses}

Enjoy your coding! 
\section{Appendix}

\subsection{Build-in Macro Functions using Array}
\label{subsec:arrayreturn}
Many built-in macro functions return an array, to have multiple numerical values as a singular object. Below is a list of those functions. 

\begin{shaded}\begin{indentCom}
\texttt{
\item Dialog.addChoice("Label", items) 
\item Dialog.addChoice("Label", items, default)
\item Fit.doFit(equation, xpoints, ypoints)
\item Fit.doFit(equation, xpoints, ypoints, initialGuesses)
\item getFileList(directory)
\item getHistogram(values, counts, nBins[, histMin, histMax])
\item getList("window.titles")
\item getList("java.properties")
\item getLut(reds, greens, blues)
\item getProfile()
\item getRawStatistics(nPixels, mean, min, max, std, histogram)
\item getSelectionCoordinates(xCoordinates, yCoordinates)
\item getStatistics(area, mean, min, max, std, histogram)
\item makeSelection(type, xcoord, ycoord)
\item newArray(size)
\item newMenu(macroName, stringArray)
\item Plot.create("Title", "X-axis Label", "Y-axis Label", xValues, yValues)
\item Plot.add("circles", xValues, yValues)
\item Plot.getValues(xpoints, ypoints)
\item setLut(reds, greens, blues)
\item split(string, delimiters) 
}
\end{indentCom}\end{shaded}


 


\end{document}
